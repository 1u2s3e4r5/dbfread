dbfget - Python library for getting data out of DBF files
=========================================================

Requires Python 2.7 or 3.2 (works in both without change)

Project page: http://nerdly.info/ole/dbf/

License: MIT

Latest version of the source code: https://github.com/olemb/dbfget/


Example
-------

::

    >>> import dbfget
    >>> cables = dbfget.read('cables.dbf')

This returns a table object, which is a subclass of list. The list
contains all records from the table as normal Python dictionaries::

    >>> len(cables)
    552
    >>> for c in cables:
    ...     print c['CABLE'], c['LENGTH']

There is also a list of deleted records, should you need to recover them::

    >>> len(cables.deleted)
    3


Status
------

This code in various incarnations has been in production at the
University of Tromsø since 2001. The current version reads all data
generated by Telemator (http://www.telemator.no/), which uses Visual
Foxpro (as far as I can tell) and employs a wide range of data types.

The library has not been widely tested on other data, but I intend for
it to be able to read ANY DBF file. If you have a file it can't read,
or find a bug, I'd love to hear from you.


Installing
----------

Python 2::

  sudo python setup.py install

Python 3::

  sudo python3 setup.py install
    

Features
--------

  - the table object is a subclass of list
  - records are dictionaries
  - data is converted to native Python types
    (see Supported field types below)
  - records can optionally be returned as any kind of object
    (using the recfactory option, which defaults to ``dict``)
  - reads memo fields (.fpt) and returns them as unicode strings
    (binary memo fields are returned as byte strings)
  - strings are decoded and returned as unicode
    (defaults to 'latin1', unless you supply a the ``encoding``
    option)
  - file name case agnostic (``read('kabreg.dbf')`` will find
    ``KabReg.dbf`` and the memo file ``KABREG.FPT``). This
    (behaviour can be turned off by passing ``ignorecase=False``)


Supported field types
----------------------

=  ==========  ====================================================================
:  Field type   Converted to
=  ==========  ====================================================================
0  flags       int
C  text        unicode string
D  date        datetime.date or None
F  float       float or None
I  integer     int or None
L  logical     True, False or None
M  memo        unicode string (memo type) or byte string (picture and object type)
N  numeric     int, float or None
T  time        datetime.datetime
=  ==========  ====================================================================


Possible future features
------------------------

  - auto-detection of code page / encoding. This is tricky, since
    the value is stored in only one byte, which is vendor specific,
    and in most files I've seen is just set to 0.
  - easy export to SQL / CSV
  - raw mode (to get all values as raw byte strings)

    
More examples
-------------

The table object has a lot of useful attributes::

    >>> cables.name
    'cables'
    
    >>> cables.date
    datetime.date(2012, 7, 11)

    >>> cables.encoding
    'cp1252'

    >>> cables.field_names
    [u'CABLE', u'OWNER', u'USAGE', u'CORETYPE', u'NUMCORES',
    u'END_A', u'END_B', u'LENGTH', u'DTPLACED', u'COVERAGE', u'REMARKM',
    u'TYPECODE', u'BROKEN', u'AUTROUTBLK', u'UPDWHEN', u'UPDVER', u'UPDUSER',
    u'SPEED', u'TSLST]

    >>> cables.fields
    [DBFField(name=u'CABLE', type=u'C', address=1, length=25, decimal_count=0,
    reserved1=0, workarea_id=0, reserved2=0, reserved3=0, set_fields_flag=0,
    reserved4='\x00\x00\x00\x00\x00\x00\x00', index_field_flag=0),
    ... etc. ...]

    >>> cables.header
    DBFHeader(dbversion=48, year=12, month=7, day=11, numrecords=555,
    headerlen=2408, recordlen=632, reserved1=0, incomplete_transaction=0,
    encryption_flag=0, free_record_thread=0, reserved2=0, reserved3=0,
    mdx_flag=3, language_driver=3, reserved4=0)


Options
-------

By default, dbfget.read() will try to guess the character encoding
from the language_driver byte. This doesn't always succeed. You can
override the encoding with the option::

   encoding='latin1'

If you want records returned as objects instead of dictionaries, you
can use this option::

   recfactory=dbfget.RecObject

If you combine that with this option::

   lowernames=True

the simple example above becomes::

    >>> import dbfget
    >>> cables = dbfget.read('cables.dbf')
    >>> for c in cables:
    ...     print c.cable, c.length

The ``recfactory`` option takes any callable which accepts a list of
```(name, value)``` tuples, for example::

   recfactory=collections.OrderedDict

One last option. By default, dbfget will assume that you've copied the DBF files
from a windows file system, and that the file name casing is all scrambled. Thus,
it will treat ```Cables.FPT``` as the same file as ```CABLES.fpt```. You can turn
off this behaviour with::

   ignorecase=False


Contact
--------

Ole Martin Bjørndalen - ombdalen@gmail.com - http://nerdly.info/ole/
